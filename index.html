<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图像几何校正 - Pure JS</title>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* 顶部参数配置区 */
        .config-panel {
            background: #2d2d2d;
            padding: 15px 20px;
            border-bottom: 2px solid #3d3d3d;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .config-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-group label {
            font-size: 14px;
            color: #aaa;
        }

        .config-group input[type="number"] {
            width: 80px;
            padding: 8px 12px;
            background: #3d3d3d;
            border: 1px solid #4d4d4d;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
        }

        .config-group input[type="number"]:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .btn {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #45a049;
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #2196F3;
        }

        .btn-secondary:hover {
            background: #0b7dda;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            padding: 10px 20px;
            background: #FF9800;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: inline-block;
            transition: background 0.3s;
        }

        .file-input-label:hover {
            background: #e68900;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            font-size: 14px;
            color: #aaa;
            cursor: pointer;
        }

        .status {
            margin-left: auto;
            font-size: 13px;
            color: #888;
        }

        .status.loading {
            color: #FF9800;
        }

        .status.success {
            color: #4CAF50;
        }

        .status.error {
            color: #f44336;
        }

        /* 加载遮罩 */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: #fff;
        }

        /* 图像显示区 */
        .image-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            background: #252525;
            padding: 10px 15px;
            font-size: 14px;
            color: #aaa;
            border-bottom: 1px solid #3d3d3d;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            background: #1e1e1e;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        canvas {
            display: block;
            max-width: none;
        }

        /* 控制点样式 */
        .control-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 0, 0.8);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: move;
            transform: translate(-50%, -50%);
            z-index: 10;
            transition: background 0.2s;
        }

        .control-point:hover {
            background: rgba(255, 50, 50, 1);
        }

        .control-point.dragging {
            background: rgba(255, 100, 100, 1);
            z-index: 100;
        }

        /* 空状态提示 */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #555;
            font-size: 16px;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 15px;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <!-- OpenCV加载遮罩 -->
    <div class="loading-overlay" id="opencvLoading">
        <div class="spinner"></div>
        <div class="loading-text">正在加载 OpenCV.js...</div>
    </div>

    <!-- 处理中遮罩 -->
    <div class="loading-overlay hidden" id="processingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">正在处理...</div>
    </div>

    <div class="container">
        <!-- 顶部参数配置区 -->
        <div class="config-panel">
            <div class="file-input-wrapper">
                <input type="file" id="imageInput" accept="image/*">
                <label for="imageInput" class="file-input-label">选择图像</label>
            </div>

            <div class="config-group">
                <label for="gridX">横向控制点 (X):</label>
                <input type="number" id="gridX" min="2" value="6">
            </div>

            <div class="config-group">
                <label for="gridY">纵向控制点 (Y):</label>
                <input type="number" id="gridY" min="2" value="6">
            </div>

            <button class="btn btn-secondary" id="updateGridBtn">更新网格</button>

            <div class="checkbox-group">
                <input type="checkbox" id="realtimeWarp">
                <label for="realtimeWarp">实时Warp处理</label>
            </div>

            <button class="btn" id="warpBtn" disabled>执行Warp</button>

            <button class="btn btn-secondary" id="saveBtn" disabled style="background: #9C27B0;">保存图像</button>

            <div class="status" id="status">等待OpenCV.js加载...</div>
        </div>

        <!-- 图像显示区 -->
        <div class="image-area">
            <div class="panel-header">图像显示 (拖拽红色控制点进行几何校正)</div>
            <div class="canvas-container" id="canvasContainer">
                <div class="empty-state">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
                    </svg>
                    <span>请选择图像文件</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // OpenCV.js加载完成回调
        function onOpenCvReady() {
            console.log('OpenCV.js is ready');
            document.getElementById('opencvLoading').classList.add('hidden');
            setStatus('OpenCV.js 已加载，请选择图像', 'success');
            cvReady = true;
        }

        // 全局状态
        const state = {
            originalImage: null,
            displayImage: null,
            originalImageData: null,  // cv::Mat
            gridX: 6,
            gridY: 6,
            controlPoints: [],
            isDragging: false,
            draggedPoint: null,
            realtimeWarp: false,
            isWarped: false
        };

        let cvReady = false;

        // DOM元素
        const elements = {
            imageInput: document.getElementById('imageInput'),
            gridX: document.getElementById('gridX'),
            gridY: document.getElementById('gridY'),
            updateGridBtn: document.getElementById('updateGridBtn'),
            warpBtn: document.getElementById('warpBtn'),
            saveBtn: document.getElementById('saveBtn'),
            realtimeWarp: document.getElementById('realtimeWarp'),
            status: document.getElementById('status'),
            canvasContainer: document.getElementById('canvasContainer'),
            opencvLoading: document.getElementById('opencvLoading'),
            processingOverlay: document.getElementById('processingOverlay')
        };

        // 初始化控制点
        function initControlPoints() {
            state.controlPoints = [];
            const cellWidth = state.originalImage.width / (state.gridX - 1);
            const cellHeight = state.originalImage.height / (state.gridY - 1);

            for (let y = 0; y < state.gridY; y++) {
                for (let x = 0; x < state.gridX; x++) {
                    state.controlPoints.push({
                        id: `${x}-${y}`,
                        originalX: x * cellWidth,
                        originalY: y * cellHeight,
                        currentX: x * cellWidth,
                        currentY: y * cellHeight
                    });
                }
            }
            state.isWarped = false;
        }

        // 绘制图像（带网格线和控制点）
        function drawImage() {
            if (!state.displayImage) return;

            const canvas = document.createElement('canvas');
            canvas.width = state.displayImage.width;
            canvas.height = state.displayImage.height;
            const ctx = canvas.getContext('2d');

            // 绘制图像
            ctx.drawImage(state.displayImage, 0, 0);

            // 绘制网格线
            drawGridLines(ctx, canvas.width, canvas.height);

            // 更新容器
            elements.canvasContainer.innerHTML = '';
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';
            wrapper.style.position = 'relative';
            wrapper.appendChild(canvas);

            // 添加控制点
            state.controlPoints.forEach((point, index) => {
                const pointEl = document.createElement('div');
                pointEl.className = 'control-point';
                pointEl.dataset.index = index;
                pointEl.style.left = point.currentX + 'px';
                pointEl.style.top = point.currentY + 'px';
                pointEl.addEventListener('mousedown', startDrag);
                wrapper.appendChild(pointEl);
            });

            elements.canvasContainer.appendChild(wrapper);
        }

        // 绘制网格线
        function drawGridLines(ctx, width, height) {
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
            ctx.lineWidth = 1;

            // 垂直线
            for (let x = 0; x < state.gridX; x++) {
                ctx.beginPath();
                for (let y = 0; y < state.gridY; y++) {
                    const index = y * state.gridX + x;
                    const point = state.controlPoints[index];
                    if (y === 0) {
                        ctx.moveTo(point.currentX, point.currentY);
                    } else {
                        ctx.lineTo(point.currentX, point.currentY);
                    }
                }
                ctx.stroke();
            }

            // 水平线
            for (let y = 0; y < state.gridY; y++) {
                ctx.beginPath();
                for (let x = 0; x < state.gridX; x++) {
                    const index = y * state.gridX + x;
                    const point = state.controlPoints[index];
                    if (x === 0) {
                        ctx.moveTo(point.currentX, point.currentY);
                    } else {
                        ctx.lineTo(point.currentX, point.currentY);
                    }
                }
                ctx.stroke();
            }
        }

        // 开始拖拽
        function startDrag(e) {
            e.preventDefault();
            state.isDragging = true;
            state.draggedPoint = parseInt(e.target.dataset.index);
            e.target.classList.add('dragging');

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
        }

        // 拖拽中
        function drag(e) {
            if (!state.isDragging) return;

            const wrapper = elements.canvasContainer.querySelector('.canvas-wrapper');
            const rect = wrapper.getBoundingClientRect();
            const canvas = wrapper.querySelector('canvas');

            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clampedX = Math.max(0, Math.min(canvas.width, x));
            const clampedY = Math.max(0, Math.min(canvas.height, y));

            state.controlPoints[state.draggedPoint].currentX = clampedX;
            state.controlPoints[state.draggedPoint].currentY = clampedY;

            const pointEl = wrapper.querySelectorAll('.control-point')[state.draggedPoint];
            pointEl.style.left = clampedX + 'px';
            pointEl.style.top = clampedY + 'px';

            const ctx = canvas.getContext('2d');
            ctx.drawImage(state.displayImage, 0, 0);
            drawGridLines(ctx, canvas.width, canvas.height);

            if (state.realtimeWarp) {
                performWarp();
            }
        }

        // 停止拖拽
        function stopDrag(e) {
            if (!state.isDragging) return;

            const wrapper = elements.canvasContainer.querySelector('.canvas-wrapper');
            const pointEl = wrapper.querySelectorAll('.control-point')[state.draggedPoint];
            pointEl.classList.remove('dragging');

            state.isDragging = false;
            state.draggedPoint = null;

            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // 执行Warp（使用OpenCV.js）
        async function performWarp() {
            if (!state.originalImageData || !cvReady) return;

            elements.processingOverlay.classList.remove('hidden');

            // 使用setTimeout让UI有机会更新
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const height = state.originalImageData.rows;
                const width = state.originalImageData.cols;

                // 创建结果图像（BGRA格式用于alpha混合）
                const result = new cv.Mat(height, width, cv.CV_8UC4);
                cv.cvtColor(state.originalImageData, result, cv.COLOR_BGR2BGRA);

                const moveThreshold = 2.0;
                let warpedCount = 0;

                // 遍历每个网格单元
                for (let y = 0; y < state.gridY - 1; y++) {
                    for (let x = 0; x < state.gridX - 1; x++) {
                        const tl = y * state.gridX + x;
                        const tr = y * state.gridX + (x + 1);
                        const bl = (y + 1) * state.gridX + x;
                        const br = (y + 1) * state.gridX + (x + 1);

                        const src_tl = state.controlPoints[tl];
                        const src_tr = state.controlPoints[tr];
                        const src_bl = state.controlPoints[bl];
                        const src_br = state.controlPoints[br];

                        const dst_tl = state.controlPoints[tl];
                        const dst_tr = state.controlPoints[tr];
                        const dst_bl = state.controlPoints[bl];
                        const dst_br = state.controlPoints[br];

                        // 检查是否有角点移动
                        let moved = false;
                        let maxMove = 0;
                        const points = [
                            [src_tl, dst_tl],
                            [src_tr, dst_tr],
                            [src_bl, dst_bl],
                            [src_br, dst_br]
                        ];

                        for (const [src, dst] of points) {
                            const dist = Math.sqrt(
                                Math.pow(src.originalX - dst.currentX, 2) +
                                Math.pow(src.originalY - dst.currentY, 2)
                            );
                            maxMove = Math.max(maxMove, dist);
                            if (dist > moveThreshold) moved = true;
                        }

                        if (!moved) continue;

                        warpedCount++;

                        // 三角形1: tl, tr, bl (上三角)
                        // 三角形2: tr, br, bl (下三角)
                        const triangles = [
                            {
                                src: [src_tl, src_tr, src_bl],
                                dst: [dst_tl, dst_tr, dst_bl]
                            },
                            {
                                src: [src_tr, src_br, src_bl],
                                dst: [dst_tr, dst_br, dst_bl]
                            }
                        ];

                        for (const tri of triangles) {
                            await processTriangle(result, tri.src, tri.dst, width, height);
                        }
                    }
                }

                console.log(`Warp完成: ${warpedCount}个单元被变换`);

                // 转换为RGBA并显示
                const resultRgba = new cv.Mat();
                cv.cvtColor(result, resultRgba, cv.COLOR_BGRA2RGBA);

                // 转换为canvas图像
                const imageData = new ImageData(
                    new Uint8ClampedArray(resultRgba.data),
                    resultRgba.cols,
                    resultRgba.rows
                );

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imageData, 0, 0);

                const img = new Image();
                img.onload = () => {
                    // 将warp后的图像设为新的原始图像
                    state.originalImage = img;
                    state.displayImage = img;
                    state.isWarped = true;

                    // 更新OpenCV Mat为warp后的图像
                    if (state.originalImageData) {
                        state.originalImageData.delete();
                    }
                    state.originalImageData = resultRgba.clone();

                    // 重新初始化控制点（基于新图像）
                    initControlPoints();
                    drawImage();
                    setStatus('Warp处理完成', 'success');
                    elements.processingOverlay.classList.add('hidden');
                };
                img.src = tempCanvas.toDataURL();

                // 注意：resultRgba在回调中克隆，不在这里删除
                result.delete();

            } catch (error) {
                console.error('Warp error:', error);
                setStatus('Warp处理失败: ' + error.message, 'error');
                elements.processingOverlay.classList.add('hidden');
            }
        }

        // 处理单个三角形
        async function processTriangle(result, srcTri, dstTri, width, height) {
            // 计算源三角形边界
            const srcTriArr = srcTri.map(p => [p.originalX, p.originalY]);
            let srcXMin = Math.floor(Math.min(...srcTriArr.map(p => p[0])));
            let srcXMax = Math.ceil(Math.max(...srcTriArr.map(p => p[0])));
            let srcYMin = Math.floor(Math.min(...srcTriArr.map(p => p[1])));
            let srcYMax = Math.ceil(Math.max(...srcTriArr.map(p => p[1])));

            // 边界检查
            srcXMin = Math.max(0, srcXMin);
            srcXMax = Math.min(width, srcXMax);
            srcYMin = Math.max(0, srcYMin);
            srcYMax = Math.min(height, srcYMax);

            if (srcXMax <= srcXMin || srcYMax <= srcYMin) return;

            // 计算目标三角形边界
            const dstTriArr = dstTri.map(p => [p.currentX, p.currentY]);
            let dstXMin = Math.floor(Math.min(...dstTriArr.map(p => p[0])));
            let dstXMax = Math.ceil(Math.max(...dstTriArr.map(p => p[0])));
            let dstYMin = Math.floor(Math.min(...dstTriArr.map(p => p[1])));
            let dstYMax = Math.ceil(Math.max(...dstTriArr.map(p => p[1])));

            // 边界检查
            dstXMin = Math.max(0, dstXMin);
            dstXMax = Math.min(width, dstXMax);
            dstYMin = Math.max(0, dstYMin);
            dstYMax = Math.min(height, dstYMax);

            if (dstXMax <= dstXMin || dstYMax <= dstYMin) return;

            // 提取源区域
            const srcRegion = state.originalImageData.roi(
                new cv.Rect(srcXMin, srcYMin, srcXMax - srcXMin, srcYMax - srcYMin)
            );

            // 调整三角形坐标（相对于源区域）
            const srcTriAdj = srcTri.map(p => [
                p.originalX - srcXMin,
                p.originalY - srcYMin
            ]);

            // 调整目标三角形坐标（相对于目标区域）
            const dstTriAdj = dstTri.map(p => [
                p.currentX - dstXMin,
                p.currentY - dstYMin
            ]);

            // OpenCV格式的三角形坐标
            const srcTriMat = cv.matFromArray(3, 1, cv.CV_32FC2, [
                srcTriAdj[0][0], srcTriAdj[0][1],
                srcTriAdj[1][0], srcTriAdj[1][1],
                srcTriAdj[2][0], srcTriAdj[2][1]
            ]);

            const dstTriMat = cv.matFromArray(3, 1, cv.CV_32FC2, [
                dstTriAdj[0][0], dstTriAdj[0][1],
                dstTriAdj[1][0], dstTriAdj[1][1],
                dstTriAdj[2][0], dstTriAdj[2][1]
            ]);

            // 计算仿射变换矩阵
            const M = cv.getAffineTransform(srcTriMat, dstTriMat);

            // 创建三角形mask
            const mask = cv.Mat.zeros(srcYMax - srcYMin, srcXMax - srcXMin, cv.CV_8UC1);
            const maskPts = cv.matFromArray(3, 1, cv.CV_32SC2, [
                srcTriAdj[0][0], srcTriAdj[0][1],
                srcTriAdj[1][0], srcTriAdj[1][1],
                srcTriAdj[2][0], srcTriAdj[2][1]
            ]);
            cv.fillConvexPoly(mask, maskPts, new cv.Scalar(255, 0, 0, 0));

            // 仿射变换
            const dstW = dstXMax - dstXMin;
            const dstH = dstYMax - dstYMin;

            const warpedImg = new cv.Mat();
            cv.warpAffine(srcRegion, warpedImg, M, new cv.Size(dstW, dstH),
                cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(0));

            const warpedMask = new cv.Mat();
            cv.warpAffine(mask, warpedMask, M, new cv.Size(dstW, dstH),
                cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(0));

            // 转换为BGRA并设置alpha
            const warpedBgra = new cv.Mat();
            cv.cvtColor(warpedImg, warpedBgra, cv.COLOR_BGR2BGRA);

            // 直接将mask复制到alpha通道（第4通道，索引3）
            for (let i = 0; i < warpedBgra.data.length; i += 4) {
                const maskIdx = i / 4;
                warpedBgra.data[i + 3] = warpedMask.data[maskIdx];
            }

            // Alpha混合到结果（直接操作result数据，避免roi引用问题）
            const resultData = result.data;
            for (let y = 0; y < dstH; y++) {
                for (let x = 0; x < dstW; x++) {
                    const resultIdx = ((y + dstYMin) * width + (x + dstXMin)) * 4;
                    const warpedIdx = (y * dstW + x) * 4;

                    const alpha = warpedBgra.data[warpedIdx + 3] / 255.0;

                    resultData[resultIdx] = warpedBgra.data[warpedIdx] * alpha + resultData[resultIdx] * (1 - alpha);
                    resultData[resultIdx + 1] = warpedBgra.data[warpedIdx + 1] * alpha + resultData[resultIdx + 1] * (1 - alpha);
                    resultData[resultIdx + 2] = warpedBgra.data[warpedIdx + 2] * alpha + resultData[resultIdx + 2] * (1 - alpha);
                    resultData[resultIdx + 3] = warpedBgra.data[warpedIdx + 3] * alpha + resultData[resultIdx + 3] * (1 - alpha);
                }
            }

            // 清理
            srcRegion.delete();
            srcTriMat.delete();
            dstTriMat.delete();
            mask.delete();
            maskPts.delete();
            M.delete();
            warpedImg.delete();
            warpedMask.delete();
            warpedBgra.delete();
        }

        // 保存图像
        function saveImage() {
            if (!state.displayImage) {
                setStatus('没有可保存的图像', 'error');
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = state.displayImage.width;
            canvas.height = state.displayImage.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(state.displayImage, 0, 0);

            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'warped_image_' + Date.now() + '.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                setStatus('图像已保存', 'success');
            }, 'image/png');
        }

        // 设置状态
        function setStatus(message, type = '') {
            elements.status.textContent = message;
            elements.status.className = 'status ' + type;
        }

        // 事件监听
        elements.imageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!cvReady) {
                setStatus('OpenCV.js 尚未加载完成，请稍候', 'error');
                return;
            }

            setStatus('正在加载图像...', 'loading');

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.originalImage = img;
                    state.displayImage = img;
                    state.gridX = parseInt(elements.gridX.value) || 6;
                    state.gridY = parseInt(elements.gridY.value) || 6;

                    // 创建OpenCV Mat
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    // 转换为OpenCV格式
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    state.originalImageData = cv.matFromImageData(imageData);

                    initControlPoints();
                    drawImage();
                    elements.warpBtn.disabled = false;
                    elements.saveBtn.disabled = false;
                    setStatus('图像已加载，拖拽控制点进行几何校正', 'success');
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        elements.updateGridBtn.addEventListener('click', () => {
            const newX = parseInt(elements.gridX.value);
            const newY = parseInt(elements.gridY.value);

            if (newX < 2 || newY < 2) {
                setStatus('控制点数必须大于等于2', 'error');
                return;
            }

            state.gridX = newX;
            state.gridY = newY;

            if (state.originalImage) {
                initControlPoints();
                state.displayImage = state.originalImage;
                // 重新创建Mat
                const canvas = document.createElement('canvas');
                canvas.width = state.originalImage.width;
                canvas.height = state.originalImage.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(state.originalImage, 0, 0);
                if (state.originalImageData) state.originalImageData.delete();
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                state.originalImageData = cv.matFromImageData(imageData);

                drawImage();
                setStatus('网格已更新', 'success');
            }
        });

        elements.warpBtn.addEventListener('click', performWarp);
        elements.saveBtn.addEventListener('click', saveImage);

        elements.realtimeWarp.addEventListener('change', (e) => {
            state.realtimeWarp = e.target.checked;
        });

        // 输入验证
        elements.gridX.addEventListener('change', () => {
            if (elements.gridX.value < 2) elements.gridX.value = 2;
        });

        elements.gridY.addEventListener('change', () => {
            if (elements.gridY.value < 2) elements.gridY.value = 2;
        });
    </script>
</body>
</html>
